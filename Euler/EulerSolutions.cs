namespace Euler
{
	using System;
	using System.Diagnostics;
	using System.Linq;
	using ExpectEx.NUnit;
	using NUnit.Framework;

	[TestFixture]
	public class EulerSolutions : AssertionHelperEx
	{
		/// <summary>
		/// Find the sum of all the multiples of 3 or 5 below 1000.
		/// </summary>
		[Test]
		public void Problem01()
		{
			var sum = Enumerable
				.Range(1, 999)
				.Where(n => n%3 == 0 || n%5 == 0)
				.Sum();

			Expect(() => sum == 233168);
		}

		[Test]
		public void Problem01_Algebraic()
		{
			// This is about 10-15x faster than iterating and filtering
			var sum = 0;
			for (int i = 0; i < 1000; i += 3)
			{
				sum += i;
			}
			for (int i = 0; i < 1000; i += 5)
			{
				sum += i;
			}
			for (int i = 0; i < 1000; i += 15)
			{
				sum -= i; // subtract multiples of 15
			}

			Expect(() => sum == 233168);
		}

		/// <summary>
		/// Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
		/// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
		/// By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
		/// </summary>
		[Test]
		public void Problem02()
		{
			var sum = Fibonacci.Sequence()
				.TakeWhile(n => n <= 4000000)
				.Where(n => n%2L == 0)
				.Sum();

			Expect(() => sum == 4613732);
		}

		[Test]
		public void Problem02_b()
		{
			// This is 3-400x faster than the LINQ solution
			long sum = 0;
			foreach (var n in Fibonacci.Sequence())
			{
				if (n%2 != 0) continue;
				if (n > 4000000) break;
				sum += n;
			}

			Expect(() => sum == 4613732);
		}

		/// <summary>
		/// What is the largest prime factor of the number 600851475143 ?
		/// </summary>
		[Test]
		public void Problem03()
		{
			var factors = FermatFactorization.Of(600851475143);

			Expect(() => factors.Max() == 6857);
		}

		/// <summary>
		/// Find the largest palindrome made from the product of two 3-digit numbers.
		/// </summary>
		[Test]
		public void Problem04()
		{
			/*
					999	998	997	996
				999	1,1	1,2	1,3	1,4
				998		2,2	2,3	2,4
				997			3,3	3,4
				996				4,4

				I will traverse this diagonally on the upper half only: 1,1 ; 1,2 ; 2,2 ; 1,3 ; 2,3 ; 1,4 ; etc
			 	This results in the numbers appearing in decreasing order.
			 */

			var largestPalindrome = Matrix.Traverse(999, 999, (i, j) => (999 - i)*(999 - j))
				.FirstOrDefault(Palindrome.Test);

			Expect(() => largestPalindrome == 906609);
		}

		/// <summary>
		/// What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
		/// </summary>
		[Test]
		public void Problem05()
		{
			var result = Enumerable
				.Range(1, 20)
				.Reverse()
				.Aggregate(1L, (lcm, x) => LeastCommonMultipe.Of(lcm, x));

			Expect(() => result == 232792560);
		}

		/// <summary>
		/// Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
		/// </summary>
		[Test]
		public void Problem06()
		{
			var sumOfSquares = 100*101*201/6; // sum(i^2) over [1..n] = ((n)(n+1)(2n+1))/6
			var sumOf1to100 = 100*101/2; // sum [1..n] = (n)(n+1)/2
			var squareOfSum = sumOf1to100*sumOf1to100;
			var result = squareOfSum - sumOfSquares;

			Expect(() => result == 25164150);
		}

		/// <summary>
		/// What is the 10,001st prime number?
		/// </summary>
		[Test]
		public void Problem07()
		{
			var prime = PrimeNumbers.Sequence_MemoryIntensive()
				.Skip(10000)
				.First();

			Expect(() => prime == 104743);
		}

		/// <summary>
		/// Find the greatest product of five consecutive digits in the 1000-digit number.
		/// </summary>
		[Test]
		public void Problem08()
		{
			// Sliding window approach
			// If the window contains a 0 we can skip it. 398 of the 995 windows contain a zero.
			// To reduce the number of comparisons, I will just look at the last element of each window.
			// If the last element of a window is 0, we can skip 5 windows.

			var n = ("73167176531330624919225119674426574742355349194934" +
			         "96983520312774506326239578318016984801869478851843" +
			         "85861560789112949495459501737958331952853208805511" +
			         "12540698747158523863050715693290963295227443043557" +
			         "66896648950445244523161731856403098711121722383113" +
			         "62229893423380308135336276614282806444486645238749" +
			         "30358907296290491560440772390713810515859307960866" +
			         "70172427121883998797908792274921901699720888093776" +
			         "65727333001053367881220235421809751254540594752243" +
			         "52584907711670556013604839586446706324415722155397" +
			         "53697817977846174064955149290862569321978468622482" +
			         "83972241375657056057490261407972968652414535100474" +
			         "82166370484403199890008895243450658541227588666881" +
			         "16427171479924442928230863465674813919123162824586" +
			         "17866458359124566529476545682848912883142607690042" +
			         "24219022671055626321111109370544217506941658960408" +
			         "07198403850962455444362981230987879927244284909188" +
			         "84580156166097919133875499200524063689912560717606" +
			         "05886116467109405077541002256983155200055935729725" +
			         "71636269561882670428252483600823257530420752963450")
				.ToCharArray()
				.Select(x => x - '0') // Convert ASCII code to int
				.ToArray();

			var max = 0;
			for (int i = 0; i < 995; i++)
			{
				if (n[i + 4] == 0)
				{
					i += 4; // Skip 4 + the loop iteration = 5 skipped windows
					continue;
				}
				var product = n[i]*n[i + 1]*n[i + 2]*n[i + 3]*n[i + 4];
				if (product > max)
				{
					max = product;
				}
			}

			Expect(() => max == 40824);
		}

		/// <summary>
		/// There exists exactly one Pythagorean triplet for which a + b + c = 1000.
		/// Find the product abc.
		/// </summary>
		[Test]
		public void Problem09()
		{
			// Brute force
			int a, b, c;
			for (a = 1; a < 998; a++)
			{
				for (b = 1; a + b < 999; b++)
				{
					for (c = 1; c < 998; c++)
					{
						if (a*a + b*b == c*c && a + b + c == 1000)
						{
							goto found;
						}
					}
				}
			}
			throw new Exception("Not found");
			found:
			var product = a*b*c;
			Console.WriteLine(new {a, b, c, product}.ToString());

			Expect(() => product == 31875000);
		}

		/// <summary>
		/// Find the sum of all the primes below two million.
		/// </summary>
		[Test]
		public void Problem10()
		{
			Stopwatch sw = Stopwatch.StartNew();
			long sum = 0;
			foreach (var prime in PrimeNumbers.Sequence_MemoryIntensive())
			{
				if (prime >= 2000000) break;
				sum += prime;
			}
			Console.WriteLine(sw.ElapsedMilliseconds);
			Expect(() => sum == 142913828922);
		}
	}
}